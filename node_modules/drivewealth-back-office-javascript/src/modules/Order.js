// @flow
import type { OrderCreateDetails, OrderCreateResponse } from "../types/Order";
import request from "./request";
import Account from "./Account";
import { DriveWealthError } from "./Error";

/**
 * @module
 * @example import { Order } from "drivewealth-back-office-javascript";
 */
export default class Order {
	/**
	 * @constant
	 * @property {string} MARKET
	 * @property {string} LIMIT
	 * @property {string} STOP
	 */
	static TYPES = {
		MARKET: "MARKET",
		LIMIT: "LIMIT",
		STOP: "STOP",
	};

	/**
	 * @constant
	 * @property {string} BUY
	 * @property {string} SELL
	 */
	static SIDES = {
		BUY: "BUY",
		SELL: "SELL",
	};

	/**
	 * Create a manual entry order for a particular account.
	 */
	static create(
		account: {
			accountID: string,
			accountNo: string,
		},
		order: OrderCreateDetails,
		options: {
			waitForFill?: boolean,
			fillRetryInterval: number,
			fillMaxRetries: number,
		} = {
			waitForFill: true,
			fillRetryInterval: 1000,
			fillMaxRetries: 10,
		},
	): Promise<OrderCreateResponse> {
		return new Promise((resolve, reject) => {
			request({
				method: "POST",
				endpoint: "/orders",
				body: {
					accountNo: account.accountNo,
					...order,
				},
			}).then(data => {
				const order = data.body;

				if (options.waitForFill) {
					const checkSummary = () => {
						options.fillMaxRetries--;

						Account.getBlotter(account.accountID).then(summary => {
							for (const transaction of summary.transactions) {
								if (transaction.orderId === order.orderID) {
									const isRejected: boolean = transaction.orderStatus == "8";
									const isFilled: boolean = transaction.orderStatus == "2";
									const notMarket: boolean = transaction.orderType != "1";

									if (isRejected) {
										let errorCode = "-1";
										let errorMessage = "Unknown rejection reason";
										const reason: string = transaction.updatedReason;
										const error = reason.match(/^\s*(-?\d+) (.+)$/);

										if (Array.isArray(error) && error[1] && error[2]) {
											errorCode = error[1];
											errorMessage = error[2];
										}

										return reject(new DriveWealthError(
											errorMessage,
											data.body,
											data.statusCode,
											data.headers,
											errorCode,
										));
									} else if (isFilled || notMarket ||
										options.fillMaxRetries === 0) {
										const orderDetails = {
											...order,
											...transaction,
										};

										delete orderDetails.orderId;

										return resolve(orderDetails);
									}
									break;
								}
							}

							// Only reached if the order wasn't found
							if (options.fillMaxRetries === 0) {
								return reject(new DriveWealthError(
									`No details found for Order No: ${order.orderNo}`,
									data.body,
									data.statusCode,
									data.headers,
									"-1",
								));
							} else {
								setTimeout(checkSummary, options.fillRetryInterval);
							}
						}).catch(reject);
					};

					checkSummary();
				} else {
					return resolve(order);
				}
			}).catch(reject);
		});
	}

	/**
	 * Make changes to an order.
	 */
	static reconcile(orderID: string, details: ?OrderCreateDetails): Promise<void> {
		return request({
			method: "PUT",
			endpoint: `/orders/${orderID}`,
			body: details,
		}).then(() => undefined);
	}
}
