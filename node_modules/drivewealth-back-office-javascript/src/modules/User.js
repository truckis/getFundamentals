// @flow
import request from "./request";
import Account from "./Account";
import Document from "./Document";
import { getPendingCounts, getPending } from "../internal/documents";
import type {
	UserCreateDetails,
	UserBasic,
	Note,
	NoteSubject,
	KYCUser,
	UserDetails,
	UserSearchResult,
} from "../types/User";
import type { AccountDetails } from "../types/Account";
import type { PendingCount, PendingDocument } from "../types/Document";

/**
 * @module
 * @description The Users API allows you to create a multitude of users.
 * @example import { User } from "drivewealth-back-office-javascript";
 */
export default class User {
	/**
	 * Create a new user.
	 */
	static create(details: UserCreateDetails): Promise<UserBasic> {
		return request({
			method: "POST",
			endpoint: "/users",
			body: details,
		}).then(data => data.body);
	}

	/**
	 * Get specific details about a particular user.
	 */
	static get(userID: string): Promise<UserDetails> {
		return request({ endpoint: "/users/" + userID }).then(data => data.body);
	}

	/**
	 * Edit information on a particular user.
	 */
	static edit(userID: string, details: ?UserCreateDetails): Promise<UserDetails> {
		return request({
			method: "PATCH",
			endpoint: "/users/" + userID,
			body: details,
		}).then(data => data.body);
	}

	/**
	 * @static
	 */
	static getNotes(userID: string): Promise<Array<Note>> {
		return request({
			endpoint: `/users/${userID}/notes`,
		}).then(data => data.body);
	}

	/**
	 * @static
	 */
	static createNote(userID: string, note: string, subject: NoteSubject): Promise<Note> {
		return request({
			method: "POST",
			endpoint: `/users/${userID}/notes`,
			body: {
				userID,
				subject: JSON.stringify(subject),
				note,
			},
		}).then(data => data.body);
	}

	/**
	 * Get accounts that belong to a user.
	 */
	static getAccounts(userID: string): Promise<Array<AccountDetails>> {
		return request({ endpoint: `/users/${userID}/accounts` }).then(data => data.body);
	}

	/**
	 * Search for users based on one or more fields contained in a query object.
	 */
	static advancedSearch(searchQuery: {|
		username?: string,
		firstName?: string,
		lastName?: string,
		phoneNumber?: string,
		email?: string,
	|}): Promise<Array<UserDetails>> {
		return request({
			endpoint: `/users/search?${Object.keys(searchQuery)
				.filter(key => searchQuery[key])
				.map(key => `${key}=${encodeURIComponent(String(searchQuery[key]))}`)
				.join("&")}`,
		}).then(data => data.body.resultSet);
	}

	/**
	 * @constant
	 * @property {RegExp} accountNo
	 * @property {RegExp} userID
	 * @property {RegExp} accountID
	 * @property {RegExp} phoneNumber
	 * @property {RegExp} fullName
	 */
	static REGEXPS = {
		accountNo: /^[A-Za-z]{4}\d{6}$/,
		userID: /^[A-Za-z\d]{8}-[A-Za-z\d]{4}-[A-Za-z\d]{4}-[A-Za-z\d]{4}-[A-Za-z\d]{12}$/,
		// eslint-disable-next-line max-len
		accountID: /^[A-Za-z\d]{8}-[A-Za-z\d]{4}-[A-Za-z\d]{4}-[A-Za-z\d]{4}-[A-Za-z\d]{12}\.\d{13}$/,
		phoneNumber: /^\d{4}$/,
		fullName: /\S+ \S+/,
	};

	static getFieldsToSearch(rawQuery: string) {
		const fields = ["accountNo", "userID", "accountID", "phoneNumber", "fullName"];

		for (const field of fields) {
			if (User.REGEXPS[field].test(rawQuery)) {
				return [field];
			}
		}

		return ["username", "firstName", "lastName", "email"];
	}

	static getSearchQuery(rawQuery: string): { [field: string]: string } {
		return User.getFieldsToSearch(rawQuery)
			.reduce((searchQuery, field) => ({
				...searchQuery,
				[field]: rawQuery,
			}), {});
	}

	/**
	 * Search for users.
	 *
	 * @param {string} rawQuery can be a userID, accountNo, accountID,
	 * phoneNumber, fullName, username, firstName, lastName, or email.
	 */
	static search(rawQuery: string): Promise<Array<UserDetails | UserSearchResult>> {
		const searchQuery = User.getSearchQuery(rawQuery);

		// each type of query may use a different request method
		const requests: Array<Promise<UserDetails | Array<UserDetails> | Array<UserSearchResult>>> =
			Object.keys(searchQuery)
				.map(field => {
					const value = searchQuery[field].trim();
					switch (field) {
						case "userID":
							return User.get(value);

						case "accountNo":
							return Account.getByAccountNo(value).then(
								account => User.get(account.userID),
							);

						case "accountID":
							return Account.get(value).then(
								account => User.get(account.userID),
							);

						case "fullName": {
							const [first, last] = value.split(/\s/);

							return request({
								endpoint: `/users/search?firstName=${first}&lastName=${last}`,
							})
								.then((data): Array<UserSearchResult> => data.body.resultSet);
						}

						case "username":
						case "firstName":
						case "lastName":
						case "phoneNumber":
						case "email":
							return request({
								endpoint: `/users/search?${field}=${value}`,
							})
								.then((data): Array<UserSearchResult> => data.body.resultSet);

						default: {
							throw new Error(
								`Attempted to search for an unknown query type (${field})`,
							);
						}
					}
				});

		return Promise.all(requests)
			.then(responses => {
				// transform nested array into single-level array
				const results: Array<UserDetails | UserSearchResult> = responses.reduce(
					(acc, next) => [...acc, ...(Array.isArray(next) ? next : [next])],
					[],
				);

				// remove duplicate results by converting from array to object and back to array
				const resultsByID: { [userID: string]: Object } = results.reduce(
					(acc, next: UserDetails | UserSearchResult) => {
						// Can we simplify this type? Couldn't find a way to make it simpler in Flow
						const userID: string = typeof next.id === "string" ? next.id :
							typeof next.userID === "string" ? next.userID : "";

						return Object.assign({}, acc, { [userID]: next });
					},
					{},
				);
				return Object.keys(resultsByID).map(key => resultsByID[key]);
			});
	}

	/**
	 * Get documents that belong to a user.
	 */
	static getDocuments(userID: string): Promise<Array<Document>> {
		return request({
			endpoint: `/users/${userID}/documents`,
		}).then(data => data.body);
	}

	/**
	 * Creates a new document from a base64 image string or a JavaScript Image file.
	 */
	static createDocument(userID: string, type: string, image: string | File): Promise<void> {
		return Document.create(userID, type, image);
	}

	/**
	 * @static
	 */
	static openDocument(documentID: string): Promise<string> {
		return Document.getURL(documentID);
	}

	/**
	 * static
	 */
	static getKYCUsers(): Promise<Array<KYCUser>> {
		return request({
			endpoint: "/users/kyc-exception",
		}).then(data => data.body);
	}

	/**
	 * @static
	 */
	static patchKYCUsers(method: string, ...userIDs: Array<string>): Promise<void> {
		return Promise.all(
			userIDs.map(userID => request({
				endpoint: `/users/kyc-exception/${userID}`,
				method: "PATCH",
				body: {
					method: method.toUpperCase(),
				},
			})),
		)
		// if the method declaration says it returns void, it should
			.then(() => {});
	}

	/**
	 * @static
	 */
	static getPendingCounts(): Promise<Array<PendingCount>> {
		return getPendingCounts("users");
	}

	/**
	 * @static
	 * @param query
	 */
	static getPending(query: Array<string> | string): Promise<Array<PendingDocument>> {
		return getPending("nextPendingUserApproval", query);
	}

	/**
	 * @static
	 */
	static review(userID: string): Promise<void> {
		return request({
			method: "POST",
			endpoint: "/users/review",
			body: { userID },
		}).then(() => undefined);
	}

	/**
	 * @static
	 */
	static updateUserRole(
		permissionGroupID: string,
		userID: string,
	): Promise<UserDetails> {
		const type = "PERMISSIONS_INFO";
		const body = {
			"documents": [{
				type,
				data: {
					id: permissionGroupID,
				},
			}],
		};

		return request({
			method: "PATCH",
			endpoint: `/users/${userID}`,
			body,
		}).then(data => data.body);
	}
}
