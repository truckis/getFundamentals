// @flow
import { Config, HOSTS } from "./Config";
import { DriveWealthError, DriveWealthSessionError } from "./Error";
import Sessions from "../internal/Sessions";

/**
 * @function request
 * @description Normally, it is unnecessary to use this function and this is for internal use only.
 *  Call request() if you need to make a custom API call that is not covered by another function.
 * @param {object} options
 * @param {string} options.method
 * @param {string} options.endpoint
 * @param {string} options.sessionKey
 * @param {string} options.body
 * @param {Object.<string, string>} options.addlHeaders
 * @param {string} options.host - One of Config.HOSTS
 * @returns {Promise.<{body: string, statusCode: number, headers: Object<string, string>}>}
 */
export default function request({
	method = "GET",
	endpoint,
	sessionKey,
	body,
	addlHeaders = {},
	host = HOSTS.API,
	authenticated = true,
	usesAppKey = true,
}: {
	method?: string,
	endpoint: string,
	sessionKey?: string,
	body?: any,
	addlHeaders?: {[header: string]: string},
	host?: string,
	authenticated?: boolean,
	usesAppKey?: boolean,
}): Promise<{
	body: *,
	statusCode: number,
	headers: { [header: string]: string },
}> {
	if (!Config.httpImpl) throw new Error("httpImpl is not setup!");
	if (!sessionKey) {
		const savedSessionKey = Sessions.get();
		if (savedSessionKey) sessionKey = savedSessionKey;
	}

	const headers: {[header: string]: string} = {
		Accept: "application/json",
	};
	if (usesAppKey) {
		headers["dw-client-app-key"] = Config.appKey;
	}
	if (method === "POST" || method === "PUT" || method === "PATCH") {
		headers["Content-Type"] = "application/json";
	}
	if (sessionKey && authenticated) {
		headers["dw-auth-token"] = sessionKey;
	}
	for (const header in addlHeaders) {
		headers[header] = addlHeaders[header];
	}

	endpoint = Config.env[host] + endpoint;

	if (headers["Content-Type"] === "application/json") body = JSON.stringify(body);

	if (addlHeaders && addlHeaders["Content-Type"]) {
		if (!body) throw new Error("No body provided, but content-type header was set.");
		if (
			addlHeaders["Content-Type"] === "application/x-www-form-urlencoded"
			&& body instanceof Object
			&& body.constructor === Object
		) {
			const mappableObj: Object = body;
			body = Object.keys(mappableObj).map(
				key => encodeURIComponent(key) + "=" + encodeURIComponent(mappableObj[key]),
			).join("&");
		}
	}

	return new Promise((resolve, reject) =>
		Config.httpImpl(
			method,
			endpoint,
			headers,
			body,
			(statusCode, resHeaders, resBody) => { // eslint-disable-line arrow-body-style
				const contentType = resHeaders["Content-Type"] || resHeaders["content-type"] || "";
				if (resBody && contentType.indexOf("application/json") !== -1) {
					try {
						resBody = JSON.parse(resBody);
					} catch (err) {
						// resBody will remain as is
					}
				}

				if (String(statusCode)[0] === "2" || String(statusCode)[0] === "3") {
					return resolve({
						body: resBody,
						statusCode,
						headers: resHeaders,
					});
				}

				let errorMessage = "No error message was returned from the server.";
				let errorCode = "-1";
				if (resBody) {
					if (resBody.error) {
						errorMessage = resBody.error.message;
						errorCode = resBody.error.errorCode;
					}

					if (resBody.message && resBody.errorCode) {
						errorMessage = resBody.message;
						errorCode = resBody.errorCode;
					}

					if (resBody.verificationResponse) {
						errorMessage = resBody.verificationResponse.message;
						errorCode = "-1";
					}
				}

				if (statusCode === 401) {
					Config.onUnAuth();
					return reject(new DriveWealthSessionError(
						errorMessage,
						resBody,
						statusCode,
						resHeaders,
						errorCode,
					));
				}

				return reject(new DriveWealthError(
					errorMessage,
					resBody,
					statusCode,
					resHeaders,
					errorCode,
				));
			},
		));
}
